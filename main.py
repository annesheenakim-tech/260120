import streamlit as st
st.title("김신아 첫 웹앱")
st.write('안녕하세요! 반갑습니다!')

import pandas as pd

MBTI_JOBS = {
    "INTJ": [
        {"직업": "전략 컨설턴트", "이유": "복잡한 문제 구조화/장기 전략 설계"},
        {"직업": "데이터 사이언티스트", "이유": "가설 기반 분석/모델링 선호"},
        {"직업": "프로덕트 매니저", "이유": "큰 그림과 로드맵 설계"},
    ],
    "INTP": [
        {"직업": "연구원(R&D)", "이유": "개념 탐구/실험 설계 몰입"},
        {"직업": "소프트웨어 엔지니어", "이유": "논리적 문제 해결/시스템 설계"},
        {"직업": "퀀트/리서처", "이유": "모델 기반 추론/검증"},
    ],
    "ENTJ": [
        {"직업": "사업개발(BD)", "이유": "목표 중심 실행/협상/의사결정"},
        {"직업": "영업 리더", "이유": "성과 관리/조직 드라이브"},
        {"직업": "PMO/프로젝트 리더", "이유": "자원 배분/일정·리스크 관리"},
    ],
    "ENFP": [
        {"직업": "브랜드/마케팅", "이유": "스토리텔링/아이디어 발산"},
        {"직업": "콘텐츠 크리에이터", "이유": "표현/기획/커뮤니케이션"},
        {"직업": "HR(조직문화)", "이유": "사람/동기/관계 중심"},
    ],
}

# 그룹 기반 fallback: 데이터가 없어도 MBTI 선택에 따라 결과가 달라지게
GROUP_FALLBACK = {
    "NT": [
        {"직업": "전략/기획", "이유": "추상화·모델링·구조화 강점"},
        {"직업": "데이터/리서치", "이유": "가설-검증 루프에 적합"},
        {"직업": "제품/기술 기획", "이유": "시스템 관점 설계"},
    ],
    "NF": [
        {"직업": "브랜딩/콘텐츠", "이유": "가치·메시지·경험 설계"},
        {"직업": "교육/코칭", "이유": "성장 촉진·동기부여"},
        {"직업": "HR/커뮤니티", "이유": "관계·문화·소속감 설계"},
    ],
    "SJ": [
        {"직업": "운영/오퍼레이션", "이유": "프로세스·정확성·안정성"},
        {"직업": "재무/회계/관리", "이유": "규정·체계·리스크 관리"},
        {"직업": "품질/컴플라이언스", "이유": "표준 준수·검증·개선"},
    ],
    "SP": [
        {"직업": "세일즈/현장 운영", "이유": "상황대응·즉시 실행"},
        {"직업": "디자인/크리에이티브", "이유": "감각·실험·표현"},
        {"직업": "이벤트/프로덕션", "이유": "현장 문제 해결/조율"},
    ],
}

MBTI_LIST = [
    "ISTJ","ISFJ","INFJ","INTJ",
    "ISTP","ISFP","INFP","INTP",
    "ESTP","ESFP","ENFP","ENTP",
    "ESTJ","ESFJ","ENFJ","ENTJ"
]

def get_group(mbti: str) -> str:
    # 2~3번째 글자로 그룹을 대략 매핑 (N/S, T/F)
    # NT, NF, SJ, SP
    if len(mbti) != 4:
        return "SJ"
    n_or_s = mbti[1]
    t_or_f = mbti[2]
    if n_or_s == "N" and t_or_f == "T":
        return "NT"
    if n_or_s == "N" and t_or_f == "F":
        return "NF"
    if
